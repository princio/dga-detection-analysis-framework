#include "kfold_describe.h"

#include <assert.h>
#include <float.h>
#include <math.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>


void _update_kfeo(KFoldEvaluationOutput* kfeo, double value) {
        kfeo->avg += value;
        if (kfeo->min > value) kfeo->min = value;
        if (kfeo->max < value) kfeo->max = value;
}

void kfeo_falseratio(CM2* det) {
    return ((double) det->windows.falses) / (det->windows.falses + det->windows.trues);
}

void kfeo_trueratio(CM2* det) {
    return ((double) det->windows.trues) / (det->windows.falses + det->windows.trues);
}

void kfeo_falses(CM2* det) {
    return ((double) det->windows.falses);
}

void kfeo_trues(CM2* det) {
    return ((double) det->windows.trues);
}

void kfeo_sourcestrues(CM2* det) {
    int32_t sources_trues = 0;
    int32_t sources_n = 0;
    for (int32_t i = 0; i < det->sources.number; i++) {
        CM* tf = &det->sources._[i];
        if (tf->trues + tf->falses) {
            sources_n++;
        }
        sources_trues += tf->trues > 0;
    }
    return ((double) sources_trues) / sources_n;
}

void _kfd_outputs_init(MANY(KFoldEvaluationOutput)* inputs, MANY(KFoldEvaluationOutput)* outputs) {
    INITMANYREF(outputs, inputs->number, KFoldEvaluationOutput);

    for (int32_t i = 0; i < outputs->number; i++) {
        outputs->_[i].input = &inputs->_[i];
        _metrics_reset(&outputs->_[i]);
    }
}

void kfd_metrics_print(char* specifier, KFoldEvaluationOutput* metrics) {
    char format[200];
    sprintf(format, "%s%s%s", specifier, specifier, specifier);
    printf(format, metrics->avg, metrics->min, metrics->max);
}

void kfd_divide(int32_t kfolds, MANY(KFoldEvaluationOutput) fess) {
    for (int32_t i = 0; i < fess.number; i++) {
        fess._[i].avg /= kfolds;
    }
}

void kfd_update(EvaluationOutput* eo, KFoldEvaluationOutput* kfeo) {
    kfeo->input->func(kfeo, eo);
}

void kfd_run(MANY(EvaluationOutput)* eos, MANY(KFoldEvaluationInput)* inputs, MANY(KFoldEvaluationOutput)* outputs) {
    _kfd_outputs_init(inputs, outputs);

    for (int k = 0; k < eos->number; k++) {
        for (int i = 0; i < outputs->number; i++) {
            kfd_update(eos->_[k], &outputs->_[i]);
        }
    }
}

void kfd_print(FoldingEvaluationResult* fed) {
    for (int type = 0; type < N_FOLDINGEVAL_METHODS_TYPES; type++) {
        for (int id = 0; id < n_methods[type]; id++) {
            // for (int dd = 0; dd < N_PERFORMANCE_DGAHANDLINGs; dd++) {
            //     printf("dga detection = %s\n", dgadetection_names[dd]);
            //     for (int ev = 0; ev < N_EVALUATEMETHODs; ev++) {
            //         printf("\t%s\n", evaluation_methods[ev].name);
            if (type == FOLDINGEVAL_FUNC_MACRO) {
                printf("\t%20s\t", foldingevaluation_macro_methods[id].name);
                foldingevaluation_metrics_print("%12.4f", &fed->macro[id]);
            } else {
                for (int32_t cl = 0; cl < N_DGACLASSES; cl++) {
                    printf("%20s\t", foldingevaluation_micro_methods[id].name);
                    foldingevaluation_metrics_print("%12.4f", &fed->micro[id][cl]);
                    //     }
                    // }
                }
            }
        }
    }
}